#operating system_5th
>进程间通信
>管程
>线程

##进程间通信
>进程之间传送数据，协调使用共有资源

有两种通信方式
 + 低级方式：`只能传递状态和整数值`
 + 高级方式：可以传输任意数量的数据，`需要使用send/receive原语`

>直接方式：直接将数据从源进程发到目的进程
>间接方式：将数据发给中转站，然后目的进程按需接受数据

下面依次介绍三种通信方式
###通道
`老师上课没讲，也没有来得及学习，稍后补齐`
###信息缓存区
  通过send/receive原语来实现信息的传输和接收

send原语：

				//直接形式
		send(R,M)
		{
			根据R找接受进程
			如果没找到，出错返回
			申请缓冲区
			p(s-b)//s-b初始值为n
			BEGIN
			//申请缓冲区
			p(s-mutex)
			摘空缓冲区
			v(s-mutex)
			copy(M);//将信息发送给缓冲区
			p(r-mutex)
			//将缓冲区链接到接受方的信息缓冲区队列的队尾
			v(r-mutex)
			v（s-m）//s-m的初始值为0
		}

		receive(S,M);

		//间接形式
		send(MB,M);
		RECEIVE(MB,M);

>思考题：![Alt text](./1571130790370.png)
如果第一个语句和第一个语句交换位置，会产生什么后果

###内存共享
多个进程共享同一段内存
需要使用并行和互斥机制保证数据一致性
***
##管程
 利用面向对象的方法实现对临界区的访问，将共有的资源和对资源的操作封装在一个类中，称为管程（monitor），进程调用管程来访问临界区资源
 利用信号量来对照理解管程模式
+ 与互斥相对应：
	+ 在一个进程在调用管程时另外一个管程申请管程则列入等待入口队列的队尾，在进程归还管程后再根据优先级调用进程

+ 与阻塞子队列对应：
	+  当一个进程在进入管程时发现执行条件不满足，则创建或查找该条件下的等待队列，将该进程链入队列中并归还管程，如果新的进程进入管程并使条件满足，则等待队列中的进程被删除，并调入入口等待队列中


+ 就绪队列
	+ 即入口等待队列
>管程必须互斥进入

##线程：
>用户级线程、核心级线程、轻量级进程

*引入线程的目的是为了`简化线程间的通信`，并以更小的开销提高线程的并发性*
***
>线程库需要实现的操作
>+ 创建、撤销线程
>+ 完成线程间的通信
>+ 进行线程间的调度
>+ 保护和恢复线程上下文
>
>线程
>+ 只拥有基本的资源：线程状态，寄存器上下文和栈
>+ 有三种基本状态
>+ 不运行时保存上下文
>+ 有一个执行栈
>+ 静态存储局部变量
>+ 可以存取共享的资源
>+ 可以创建和撤销另一个进程

###用户级线程
 >用户线程的管理不依赖于OS核心，全部由用户程序完成，操作系统核心只对进程进行管理。
应用进程利用线程库提供创建、同步、调度和管理线程的函数来控制用户线程。如：数据库系统informix，图形处理Aldus PageMaker。调度由应用软件内部进行，通常采用非抢先式和更简单的规则，也无需用户态/核心态切换，所以速度特别快。

+ 用户级线程的优点：
	+ 1.因为是用户管理线程，不需要进入核心态，所以线程的调度和通信特别快
	+ 2.`调度是程序特定的，可以使用对不同程序而言更高效的算法`
	+ 3.，`只要有线程库`就可以在不同操作系统中运行

+ 用户级线程的缺点：
	+ 1.因为调用cpu的单位是进程，因此线程只能占用一个cpu，不能多个cpu同时执行，因此在多线程进程时速度会变慢
	+ 2.``大多数系统调用是阻塞的，因此当一个线程因为系统调用阻塞的时候，整个进程就阻塞了。

###核心级线程
> 依赖于OS核心，所有线程管理由核心完成。在核心中保留了一个线程控制块，系统根据该线程控制块而感知该线程的存在，并由内核的内部需求进行创建和撤销，用来执行一个指定的函数
![image.png](https://i.loli.net/2019/10/19/IvchmDZek68NgqJ.png)

+ 特点：
	+ 内核维护线程的上下文
	+ 一个线程阻塞不会引起整个进程的阻塞
	+ 以线程为基础进行调度

+ 核心级线程的优点：
	+ 对于多处理器，系统可以同时调用同一进程的多个进程
	+ 阻塞在线程一级完成的
	+ 线程的阻塞不会引起进程的阻塞
+ 核心级线程的缺点：
	+ 同一进程的不同线程调度会由核心完成，会导致线程变慢。
###轻权进程

通过核心态线程来完成线程调度，通过用户态线程来完成线程创建，核心态进程和用户态进程会通过LWP对应起来。
>每个ULT利用LWP与内核通信；
   每个LWP支持一个或多个用户级线程，并映射到一个核心级线程；
   每个LWP对应用程序可见，内核看到的是多个LWP而看不到ULT。

