# operation system_3rd
	进程状态的转换和进程控制
##进程状态的转换

	七状态的情况下的新的转换
	
	+ 增加了挂起和激活状态
		+ 运行->就绪挂起（单步调试/高优先级进程剥夺）
		+ 就绪->就绪挂起（高优先级的就绪进程出现）
		+ 阻塞->阻塞挂起（内存中阻塞的进程过多，为了给新的进程留出足够的空间而将将内存中的进程挂起到外存中）
		+ 阻塞挂起->阻塞
		+ 就绪挂起->就绪


##进程控制
	### 进程原语
	>由若干条指令构成的“原子操作(atomic operation)”过程，作为一个整体而不可分割－－要么全都完成，要么全都不做。许多系统调用就是原语。

	系统调用不是原语的例子：
		一个进程调用了read()，但是因为无法读取而产生了中断，此时有可能有另外一个进程来调用read()这个系统调用函数

	### 原语细节
	>创建/终止  阻塞/唤醒  挂起/激活

+ 创建原语
	+ 什么时候会创建进程
		+ 分时操作系统，终端用户登录，创建shell进程调用
		+ >批处理操作系统，作业调度，选中一个作业为它创建进程
		+ 用户提出资源请求要求，系统创建进程
		+ 应用程序创建进程，以完成某项工作
>子进程可以从父进程中继承用户标识符、环境变量、打开文件、文件系统的当前目录、控制终端、已经连接的共享存储区、信号处理例程入口表等
	+ 创建原语的过程：
		+ 分配pcb块
		+ 设置优先级
		+ >初始化cpu保护区f
		+ 记录分配的资源
		+ 设置就绪状态
		+ 填入父、子进程
		+ 插入到就绪队列中
+ 终止原语
	+ 什么时候会终止进程
		+ 正常结束
		+ 异常中止
		+ 外部干预（任务管理器）
	+ 终止原语的过程：
		+ 搜索pcb块
		+ 如果是执行态则停止
		+ 递归终止子进程
		+ 如果有父进程的资源就归还给父进程
		+ 自身调用的资源归还给系统
		+ >pcb从链表中移出
		+ 进行系统调用
		+ 返回
+ 阻塞原语
	+ 什么时候会发生阻塞
		+ 等待设备/进程合作/无事可做
	+ 阻塞过程
		+ 指针指向该过程的pcb块->停止运行，保护现场->设置为运行阻塞状态->插入到p的阻塞队列中->schedule
+ 唤醒原语
	+ 从阻塞队列中删除
	+ 置状态为就绪状态
	+ 插入到就绪队列
	+ 如果是抢占式，则可能立马发生schedule
+ 挂起原语
	> 需要进程状态和进程名的状态字为参数
	
	+ 通过进程名找到该进程
	+ 如果是执行态？则，停止
	+ 保存上下文和寄存器状态到pcb中
	+ 如果非执行态，则从该字表队列中删除该进程
	+ 置状态为挂起
	+ 将程序传入外存
	+ 将pcb保存到外存中并根据进程状态参数置挂起状态
	+ schedule

+ 激活原语
	>需传入程序状态和程序名的参数
	
	+ 置程序状态为传入参数的状态
	+ 将程序传入内存
	+ 将pcb插入到内存pcb所属子表中
	+ 如果为就绪状态则恢复pcb中的上下文并执行
##进程间的相互作用
>思考题：
		>所有进程都堵塞，但是电脑没有死机是哪一种情况？

